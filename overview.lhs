\documentclass[a4paper,11pt,oneside]{article}
% addtolength might be useful for changing page margins.

% TODO: Report and article both look pretty good, decide on one.
% Report doesn't seem to recognize subsubsections?

%include lhs2TeX.fmt
%include lhs2TeX.sty
%include polycode.fmt

% \usepackage[nounderscore]{syntax}
% \usepackage{underscore}

% For table positioning
% \usepackage{float}
% \restylefloat{table}

% This provides a table of contents that okular can read.
\usepackage[a4paper]{geometry}

\usepackage{hyperref}
\hypersetup{
  colorlinks,
  citecolor=black,
  filecolor=black,
  linkcolor=black,
  urlcolor=black
}

\title{An implementation of a basic general-purpose programming language}
\author{Ben Moon}
\date{}

\begin{document}

\newcommand{\haskmodule}[1]{\texttt{#1}}
\newcommand{\hasklib}[1]{\texttt{#1}}
\newcommand{\clcmd}[1]{\texttt{#1}}


\maketitle

\begin{abstract}
  % TODO: Not sure about the 'design-process' bit.
  % NOTE(1): There is a section on design choices now.
  This document provides an overview of the design-process, usage and
  implementation of Angle - a general purpose programming language.
  \\
  Additionally, this overview will provide a language reference,
  describing each of Angle's features in detail.
  \\
  The programming language `Haskell', along with standard tools such as
  Cabal and the Glasgow Haskell Compiler have been used for the
  implementation.
  \\
  % FIXME: Not sure about the colon after including.
  Angle takes inspiration from many programming languages, including
  Perl, Lisp, Python, Ruby, and Haskell.
  \\
  The end product is twofold: the language itself, its grammar,
  implementation details and semantics; and the interpreter software
  that can be used to execute source either interactively or
  non-interactively.
  % The end product is a piece of software that can be used to run
  % syntactically correct source files either interactively or
  % non-interactively.

\end{abstract}

\tableofcontents

\newpage

\part{Introduction}
\label{prt:introduction}

% TODO: Check this paragraph!
The following section introduces Angle, some implementation concepts
and the software used to create it.
\\
% TODO: Maybe mention the 'reading this document' section?

\section{Reading this document}
\label{sec:reading_this_document}

% FIXME: There is repetition on '...refer to the source files...'
This document should be read in conjunction with the source files
provided. Examples of code in this document are for illustration
purposes and should be assumed to be non-functional - the source files
should be referred to for working code.
\\

Relevant modules will be stated before any sections describing the
development of code.
\\
Additional documentation is provided in the form of HTML files
generated by Haddock. Any capable browser will be sufficient to view
the documentation interactively.

\subsection{Notation}
\label{sub:notation}


% TODO: Uhh... Do better than this.
Throughout this document, references to code, modules, and other
features will be made.

\begin{tabular}{c c c}
 Element &  Example & Represents. \\
 Modules & \haskmodule{Angle.Parse.Token} & Reference to a Haskell module. \\
 Code    & @let x = 7@ & Source code of various types. \\
 Library & \hasklib{tasty} & Reference to a Haskell library. \\
 Command & @angle --help@ & Command that can be entered at a terminal. \\
\end{tabular}

\section{Background}
\label{sec:background}

% TODO: Better phrasing, need to say that it also introduces some
% terminology.
What follows is an overview of external software and libraries used in
this project.

\subsection{Haskell}
\label{sub:haskell}

I have decided to write my project using the Haskell programming
language. Haskell is a statically-typed, functional, lazy language
that supports type-inference. \cite{Haskell}

% TODO: Want better phrasing.
Haskell's type system makes it very easy to develop projects quickly
and safely as a project will not compile unless types match up.

\subsection{Software}
\label{sub:software}

In developing Angle, I have used various software to deal with
compiling, documenting, testing and many other aspects.

\subsubsection{Cabal}
\label{ssub:cabal}

Cabal is a package manager for projects written in Haskell. \cite{Cabal}
It allows information about the package, including name, description,
library information and test suites to be specified within a
\texttt{.cabal} file, and can then be used to simplify the task of
compiling, running tests and installing packages.


\subsubsection{Haddock}
\label{ssub:haddock}

Haddock is a system for generating documentation from annotated Haskell
source files. \cite{Haddock}
I chose Haddock due to it's intuitive syntax, ease of readability and
integration with Cabal.


\subsubsection{Glasgow Haskell Compiler}
\label{ssub:glasgow_haskell_compiler}

The Glasgow Haskell Compiler, or GHC, is the main actively-maintained
compiler for Haskell. \cite{GHC} It is very
stable and provides a lot of additional features that may be used when
required by a programmer.

\subsubsection{Git}
\label{ssub:git}

Git is an open source version control system that allows changes in a
project to be staged, committed and tracked. This means that changes
to the project can easily be undone and reviewed, and allows changes
to be labeled for future reference. \cite{Git}

\subsubsection{Libraries}
\label{ssub:libraries}

Throughout the project I have used many libraries written by other
developers. Some part of the Haskell Platform \cite{Haskell Platform},
others standalone. Below are some of the packages I have used.

\begin{description}
  \item[QuickCheck] - a testing library that can generate random tests
    for checking that specified properties hold when applied to
    different data. \cite{QuickCheck}
  \item[Tasty] - a test framework that allows the combination of tests
    into a single test suite for running. \cite{Tasty}
  \item[Criterion] - a benchmarking library for measuring the
    performance of code. \cite{Criterion}
\end{description}




\section{A brief overview of language implementation}
\label{sec:a_brief_overview_of_language_implementation}

% TODO: Check this paragraph!
The following section introduces some concepts relevant to language
design, along with a summary of which concepts are most appropriate
to Angle.

\subsection{Translator Software}
\label{sub:translator_software}

% TODO: Get a link for this bit.
Translator software is used to translate a program written in one
language to another language, without loosing any functionality.
\\
Although people often refer to languages as `compiled' or
`interpreted', the translator software is distinct from the language
itself, and thus a language could be both interpreted \textit{and}
compiled.\footnote{This is quite common with the more popular
languages, for example: Python and Lisp both have compiler and
interpreter implementations.}
% TODO: Not sure about that previous paragraph!


\subsubsection{Compilers}
\label{ssub:compilers}
A compiler is a piece of software that takes a file containing the
source code for one language, and produces output in another language.
The output language is often in a form that can be executed by the
system's CPU - namely object code.

\subsubsection{Interpreters}
\label{ssub:interpreters}
Interpreters differ from compilers in that instead of programs first
being translated to machine code before being executed, instructions
are translated into pre-compiled subroutines and executed directly at
run-time, thus possibly incurring a speed decrease when compared to a
similar compiled language. \cite{Compiled Versus Interpreted Languages}
\\
One of the main disadvantages of an interpreter is that it is
required every time a program needs to be run. Source code is also
more transparent (which may or may not be a disadvantage), as the
files are run directly by the interpreter.

\subsubsection{Angle}
\label{ssub:angle}

Angle is an interpreted language and this project develops the
\clcmd{angle} command-line interpreter for executing Angle source
files.


\subsection{Programming Paradigms}
\label{sub:programming_paradigms}

Programming paradigms are a way of writing programs using a
programming language. Most languages encourage the use of one or more
paradigms (for example, Haskell strongly encourages the use of the
functional paradigm), but will not usually \textit{force} the
programmer to use a single one.

\paragraph{Common paradigms}
\label{par:common_paradigms}

Following is a brief description of some of the more common
paradigms. \cite{Ray Toal Paradigms}

\subsubsection{Declarative}
\label{ssub:declarative}

The declarative paradigm is one in which programs describe what
actions should be performed, but don't explicitly state \textit{how}
this should be done.
\\
Common examples of declarative languages are database query languages such as SQL.
\\
\\
\textit{The programmer specifies that the required action is retrieving a column from a table in a database. No indication of how to achieve this is given.}
\begin{spec}
SELECT column FROM table WHERE condition
\end{spec}


\subsubsection{Imperative}
\label{ssub:imperative}

In the opposite spectrum of paradigms to declarative is imperative.
In imperative languages the programmer specifies how to perform
computations via a sequence of step-by-step instructions. \cite{MSDN Functional vs. Imperative}
Contrary to declarative languages, the order of execution in
imperative languages can greatly affect the outcome of the program.


\subsubsection{Object-oriented}
\label{ssub:object_oriented}

In object-oriented languages, structures called objects, which have
state (usually represented by properties) and methods that are used
to change this state.
\\
Objects can call other objects' methods, or potentially directly
modify their properties in order to change this state.
\\
Inheritance is usually present in object-oriented languages, and
allows a parent-child relationship between different objects.
\\
\\
\textit{A python3 example of class-based object-oriented programming.}
\begin{spec}
class User:
    access = "restricted"

    def __init__(self, name):
        self.name = name


class Admin(User):
    access = "unrestricted"

    def __init__(self, name):
        super().__init__(name)


sam = Admin("Sam")
\end{spec}
% TODO: This example seems a bit redundant, make sure it is clear
% why inheritance is useful.
In the above example, it could be said that @sam@ is an @Admin@ called
@Sam@, and that a @Admin@ is a type of @User@.
\\
@access@ is a class variable, and does not rely on an instance (@sam@)
being created, thus @Admin.access == `unrestricted'@, but also
@sam.access == `unrestricted'@.


\subsubsection{Functional}
\label{ssub:functional}

In functional languages, computations are treated as the evaluation
of mathematical functions. Side-effects are usually low to
non-existent as in a purely functional language functions should be
referentially transparent (the same result should always arise with
the same arguments). \cite{HaskellWiki Functional programming}
\\
Several features are prominent in functional languages:

\begin{description}
  \item[functions as first-class citizens] this means that functions
    are treated equally when used in place of other data structures
    (integers, lists etc...) and can thus be passed around as data.
  \item[higher-order functions] functions that are higher-order can
    take functions as arguments or produce them as results. This
    makes sense when functions are first-class citizens as they should
    be generally indistinguishable from other data.
\end{description}


Haskell is an example of a purely-functional programming language.

\subsubsection{Angle}
\label{ssub:angle}

Angle is intended to be primarily a functional language. To support
this Angle provides first-class citizen functions and higher-order
functions. Angle is not intended to be a purely functional language
(like Haskell), and thus imposes no restrictions on where
side-effecting code can be performed.

\subsection{Type systems}
\label{sub:type_systems}

Type systems broadly fall under two categories based on when type
checking is performed.

\subsubsection{Static type systems}
\label{ssub:static_type_systems}

In static type systems, certain type-related criterion must be met
before a program can be executed. These criterion can ensure a
program will have well-typed operations and that types are not used
incorrectly. \cite{Keunwoo Lee CSE 341}
\\
Statically-typed languages often require the programmer to annotate
code, stating the types of variables and functions when they are
declared; leading to increased verbosity.
\footnote{Java and C, for example.}

\subsubsection{Dynamic type systems}
\label{ssub:dynamic_type_systems}

In a dynamically-typed language, types are checked at run-time, this
means that type-correctness is not ensured and errors may occur as a
result of types being used in places for which they are not valid.
\cite{C2 Dynamic Typing}

\subsubsection{Angle}
\label{ssub:angle}

% TODO: Don't like this paragraph, especially the last sentence.
Angle is dynamically typed. I chose this system for a few reasons:
firstly, it can be very difficult and time-consuming to write a type
checker, and due to time constraints this would not be feasible;
secondly, one of the more prominent features of Angle -
parameter constraints (Section~\ref{ssub:parameter_constraints})
allows the programmer to ensure that only certain types of values can
be passed into functions they define - thus allowing them to still
reason about their code in a manner similar to if a static type system
were in place.

\subsection{Typing}
\label{sub:typing}

There are two main types of type-system that are determined by the
stage in which type-checking is performed; to accompany this, there
are two main types of typing, strong and weak. These terms are not
well-defined but an outline is provided below.

\subsubsection{Strong}
\label{ssub:strong}

A strong type system is unlikely to perform any type conversions or
coercions and is likely to be quite strict about which types can be
used in different operations.

\subsubsection{Weak}
\label{ssub:weak}

Weakly-typed languages are likely to perform type conversions or
coercions and provide a lesser distinction between the different
types. \cite{C2 Weakly Typed}

\subsubsection{Angle}
\label{ssub:angle}

Angle is, in general, strongly typed; implicit coercion of types is
rarely performed and the types of variables will never be changed
without explicit instruction to do so.
\\
Angle does provide some functions for type coercion such as the
built-in `asType' function that allows the programmer to, for instance,
convert a string to a list of characters.

\subsection{Angle Summary}
\label{sub:angle_summary}

Using the terms defined in
Section~\ref{sec:a_brief_overview_of_language_implementation},
Angle can be summarized as the following:
\\
Angle is intended to be a strong and dynamically typed, functional,
interpreted, general-purpose programming language.

\begin{description}
  \item[Strong] generally types are preserved unless explicitly
  changed.
  \item[Dynamic] type checking is performed at run-time.
  \item[Functional] Angle supports functions as first class citizens
  as well as higher-order functions.
  \item[Interpreted] Source files are executed directly using the
  \clcmd{angle} command-line interpreter.
  \item[General-purpose] There was no specific use-case in mind when
  developing Angle, as such it is intended to be able to cope with the
  implementation of a variety of different types of software.
\end{description}



\section{Project Overview}
\label{sec:project_overview}

This project aims to provide the following:

\begin{description}
  \item[Angle (the library)] A collection of Haskell modules that
  define Angle's internal structure.
  \item[angle (the software)] An interpreter built upon the Angle
  library that allows programs written in Angle to be executed.
  \item[The Angle Reference] This document - outlines Angle and its
  various features.
\end{description}

\subsection{The library}
\label{sub:the_library}

The library defines all of Angle's features
(See Part~\ref{prt:language_reference}); the scanner, parser and
language representation.\footnote{See Part~\ref{prt:implementation}
for an overview of how the library was implemented.}
\\
The library is independent of the interpreter, and thus it would be
possible to write a stand-alone compiler for Angle built upon the
library directly.


\subsection{The software}
\label{sub:the_software}

The `angle' program supports two main modes of execution: interactive
and non-interactive.

\subsubsection{Interactive Angle}
\label{ssub:interactive_angle}

When Angle runs in interactive mode, the user is presented with a
prompt at which they may enter one or more lines of code which can then
be executed. This mode allows a programmer to debug code, test short
snippets and ensure code has the correct syntax before using it in a
program.

\subsubsection{Non-Interactive}
\label{ssub:non_interactive}

When Angle runs in non-interactive mode, achieved by passing a file
to be executed, a source file is read and run by the Angle
interpreter. This mode is how programs should usually be run.


\part{Language Reference}
\label{prt:language_reference}

\section{Introduction}
\label{sec:introduction}

% FIXME: Better phrasing please.
The following reference describes the language features, grammar and
methodology of Angle. Each section describes a feature or ideal of
Angle, and sections describing syntax features will include a grammar
in Extended Backus Naur form at the end.

\subsection{Notation}
\label{sub:notation}

\subsubsection{Extended Backus Naur Form (EBNF)}
\label{ssub:extended_backus_naur_form_ebnf_}

EBNF is an extended version of Backus Naur Form, a notation that can be
used to express the grammar of formal languages. \cite{LMG BNF}
\\
BNF can be used to describe context-free grammars, \cite{Matt Might BNF}
which are grammars that consist of names and expansions
(the components), meaning that it may be used to express a grammar for
Angle.


\section{Program structure}
\label{sec:program_structure}

A program written using Angle is made up of statements: statements
may in turn be made up of many more statements, a language structure
or an expression.

\subsection{Grammar}
\label{sub:grammar}

The building blocks of Angle programs are statements; statements
themselves being made of assignments, expressions and language
constructs.

\begin{spec}
stmt        = single_stmt  | multi_stmt                    ;

single_stmt = function_def | stmt_expr      | stmt_control
            | stmt_loop    | stmt_condition | stmt_assign
            | stmt_raise   | stmt_try_catch | stmt_comment ;

multi_stmt  = `{' { stmt } `}'                             ;
\end{spec}

\subsection{Comments}
\label{sub:comments}

Comments represent code that will be ignored by Angle. Comments start
with a @#@ character and continue to the end of the line.
\\
Comments should be used to document code or temporarily disable
sections of code during development; Angle throws away comment
contents before execution.

\subsubsection{Grammar}
\label{ssub:grammar}

\begin{spec}
stmt_comment = `#' { <any character except newline> } newline ;
\end{spec}


\subsection{Identifiers and reserved words}
\label{sub:identifiers_and_reserved_words}

\subsubsection{Reserved words}
\label{ssub:reserved_words}

Reserved words (or keywords) are reserved identifiers that may not be
used for variable names.
\\
The following is a list of the reserved words in Angle:
\\
\begin{tabular}{ l c c c c r }
break    & catch & continue & defun & do     & else  \\
false    & for   & if       & in    & null   & raise \\
return   & then  & true     & try   & unless & while \\
\end{tabular}


\subsubsection{Reserved identifiers}
\label{ssub:reserved_identifiers}

Certain identifiers have predefined meanings in Angle, some of these
may be overwritten, others may not.

\begin{tabular}{ l c p{7cm} }
Name & Can be overwritten? & Use \\
main & no & Whether the current program was invoked directly. \\
\_it & yes & Holds the value of the last computation. \\
as\_constr & no & Whether the current function was called as a constraint. \\
stdin & no & Handle for managing the program's standard input
stream. \\
stdout & no & Handle for managing the program's standard output
stream. \\
stderr & no & Handle for managing the program's standard error
stream. \\
\end{tabular}

\subsubsection{Grammar}
\label{ssub:grammar}

\begin{spec}

alpha          = `a'..`Z'                              ;
digit          = `0'..`9'                              ;

identifier     = simple_ident  | function_ident        ;

simple_ident   = (alpha | `_') { alpha | digit | `_' } ;
function_ident = `\$' simple_ident                     ;
\end{spec}
% FIXME: Another $ that needs escaping in the source code.
% unescape it for final document.



\subsection{Literals}
\label{sub:literals}

Literals allow the specification of constant values for some of
Angle's built-in types. \cite{Dave Marshall Literal Values}

\subsubsection{Strings}
\label{ssub:strings}

Two types of string literal are supported in Angle: backslash-escaped
and non-backslash-escaped.

By default, escape sequences in strings will be recognized (for
example, `\textbackslash n' would be recognized as a newline), but the `e' prefix
can be used to treat all backslashes literally (thus
`\textbackslash n' would become a backslash followed by an `n').

\begin{spec}
string = [ `e' ] `"' { string_char } `"' ;

string_char = <any character allowed in a Haskell String> ;
\end{spec}

Additionally, each character of a string may be represented as a
literal.

\begin{spec}
char = `'' char_char `'' ;

char_char = <any character allowed in a Haskell Char> ;
\end{spec}

Note that Angle uses the same character escaping as Haskell.
\cite{Base Data.Char}


\subsubsection{Numeric literals}
\label{ssub:numeric_literals}

Two types of numeric are supported by Angle: floats (which should
have at least the range and precision of the IEEE double-precision
type), \cite{Base Prelude Double}
 and integers.


\begin{spec}

integer = [ `-' ] digit { digit }                                 ;

float   = [ `-' ] digit { digit } `.' digit { digit }             ;

\end{spec}

\begin{spec}
boolean = `true'  | `false'                                       ;

list    = `[' { literal `,' }                                 `]' ;
range   = `('   literal `..' [ [ literal ] [ `..' literal ] ] `)' ;
\end{spec}


Note that although other values exist in the language (namely handles)
and have a show syntax, they have no read syntax and can thus only be
obtained through the use of built-in functions and language features.


\section{Data}
\label{sec:data}

% FIXME: Better phrasing please!
Within a program it is important to be able to acquire, process, and
output data. From a low level perspective, data is just represented
in binary form, but this is very inconvenient for a programmer to
work with. Thus many programming languages include what are called
`data-structures', which accommodate working with this data. Angle
is no exception and provides several data-structures, outlined below.

\begin{tabular}{ l p{7cm} l }
Datatype  & Use & Example \\
String    & Representing sets of Unicode characters & @"string"@ \\
Integer   & Representing arbitrarily large integral values & @42@ \\
Float     & Representing floating-point values & @3.14@ \\
List      & Grouping values, lists in Angle are heterogeneous meaning
that different types of data may be stored within a single list & @[1, "string", true]@ \\
Boolean   & Representing truth values & @true@ \\
Character & Representing individual Unicode characters & @`c'@ \\
Range     & Representing an enumeration across values of a certain type & @(1..7)@ \\
Null      & Special void value for when a value must be returned but it doesn't make sense to return anything else & @null@ \\
Lambda    & Representing function bodies & @(() 1;)@ \\
Keyword   & Representing constant names without strings & @:keyword@ \\
Handle    & Referencing file descriptors & @{handle: file}@ \\
\end{tabular}

More complex data structures can be built out of these basic types.
For example, a conventional hash or dictionary could be represented
by a list of lists, each of length two with a keyword as the key
and any other data as the value.

\begin{spec}
hash = [[:key1, "value1"],
        [:key2, 200]
        [:key3, (() null;)]
        ]
\end{spec}

Then, using parameter constraints (see Section~\ref{sub:parameters})
one could define a predicate that determines whether a list represents
a hash, and then be used as a constraint on any functions that should
only accept a hash.
\\
Of course this would not be nearly as efficient as the hash implementation
in many languages, but the principle of being able to build more
complex data from the standard set of types still holds.

\section{Functions}
\label{sec:functions}

Functions and subroutines (when they don't have an explicit return
value) are essentially blocks of code that can be reused. Angle
supports functions in two forms: as bare lambdas (the actual block
of code) and function-variables. There is no difference between the
call-signature-body of a function and a lambda, but in general use,
when a lambda has been given a name (through either explicit
assignment or the @defun@ statement) it is referred to as a function.

\subsection{Parameters}
\label{sub:parameters}


\subsubsection{Types of parameter}
\label{ssub:types_of_parameter}


Parameters (the variables that take on the values of arguments) in
Angle come in two forms, each with optional modifiers.
\\
The first form is the standard parameter, these are position
dependent and will take on the value of the argument placed at the
equivalent position in a function call.
\\
The second form is a catch parameter; catch parameters, when defined,
will collect any additional additional arguments into a special list
that can be accessed normally as a list, or expanded within a
function call to pass in the collected arguments. Catch parameters
allow the implementation of variadic functions.

\subsubsection{Parameter Constraints}
\label{ssub:parameter_constraints}

Parameter constraints are references
to functions attached to a parameter. When an argument is passed to
the function and the parameter in that position has a constraint, the
argument is passed to the constraint function.
\\
The function then acts as a predicate, and should return true if the
argument satisfies the constraint and false otherwise.
\\
\\
\textit{Example of using a parameter constraint to prevent division by
zero}
\begin{spec}
# A simple predicate function, it will always return true or false.
defun nonzero(x) {
  ^(== x 0);
}

# This function won't accept a zero divisor.
defun divide(x, y:@nonzero) {
  (/ x y);
}
\end{spec}

\paragraph{Restrictions}
\label{par:restrictions}

Not just any function can be used as a constraint; for the successful
use of a function as a constraint it must follow certain rules for
the constraint call:
\begin{itemize}
  \item The function must be able to take a single argument after
  any additional arguments are supplied. See
  Table~\ref{tab:calling_constraints} for some examples of valid
  and non-valid constraint calls.
  \item For the given call, the constraint \textbf{must} return a
  boolean value.
\end{itemize}

Note that Angle won't check that a function will \textit{always}
behave well as a constraint - so a function may sometimes return
a boolean, sometimes not, but still be a valid constraint for
certain use cases.

\begin{table}[ht]
  \centering
  \begin{tabular}{c c c}
    Constraint parameters & Call form    & Valid call \\
    @foo(x, y, z)@        & @x:@@foo@    & no \\
    @foo(x)@              & @x:@@foo@    & yes \\
    @foo(x, ..xs)@        & @x:@@foo@    & yes \\
    @foo(x, y)@           & @x:@@foo(1)@ & yes \\
    @foo(x, ..xs)@        & @x:@@foo(1)@ & yes \\
  \end{tabular}
  \caption{Calling constraints}\label{tab:calling_constraints}
\end{table}

\paragraph{Multi-purpose functions}
\label{par:multi_purpose_functions}

Quite often it would make sense to have a function act one way when
called as a constraint, and another way when called normally.
\\
Angle supports this behavior by providing the @as_constr@ variable.
@as_constr@ is a special variable that holds a boolean value which
is @true@ if the current context is a constraint call, and @false@
otherwise.
\\
As an example, @int@, defined below, will determine whether the passed
value is an integer or not when used as a constraint, but will attempt
to convert the given value to an integer when called normally.

\begin{spec}
defun int(x) {
  if as_constr then {
    try {
      return (== x asType(1, x));
    } catch :typeCast {
      return false;
    }
  }
  asType(1, x);
}
\end{spec}

\paragraph{Constraints outside of parameters}
\label{par:constraints_outside_of_parameters}

% FIXME: Bit of repetition here? Each paragraph says the same thing?
As constraints represent a very useful family of predicate functions,
Angle allows the programmer to call them outside of parameter lists.
\\
When called with a prefix @@\@@, a function will be called as if
it were called as a constraint in a parameter list - with the
exception of there being no implicit first argument.

\begin{spec}
int(2.0);
# 2

@int(2.0);
# false
\end{spec}

\paragraph{Constraints with arguments}
\label{par:constraints_with_arguments}

When used as a constraint in a parameter list, the first argument
to the function will be the current argument (e.g, in @(x:@@foo)@,
the first argument to @foo@ will be @x@). In this form the calling
parentheses can be omitted.
\\
Constraints can be called with more arguments, allowing great
flexibility in how constraints are used.

Given a function @foo@ with parameters @(par1, par2, par3, ..., parn)@,
the constraint call should look like
@(x:@@foo(arg2, arg3, ..., argn))@, where @argN@ will bind with
@parN@. Note that there is no @arg1@, the current argument (@x@) will
still be passed as the implicit first argument.


\begin{spec}
# x is bigger than n?
defun larger_than(x, n) {
  (> x n);
}

defun increment_large(x:@larger_than(100)) {
  (+ x 1);
}
\end{spec}

\subsubsection{Annotations}
\label{ssub:annotations}

Annotations allow the programmer to restrict the types of arguments
that are passed into a function.
\\
There are three possible annotations:

\begin{description}
  \item[@\$x@] Requires the argument to be a lambda.
  \item[@!x@] Requires the argument to be a non-lambda.
  \item[@x@] Imposes no restriction on the argument.
\end{description}

Annotations make it easy to define higher-order functions.
\begin{spec}
defun map(\$f, xs) {
  for x in xs do {
    f(x);
  }
}
\end{spec}

Annotations allow the programmer to quickly state whether the
parameter should be a function, literal or any value. This makes it
easier to reason about higher-order functions and quickly see where
functions should be passed in - as well as having the function reject
invalid arguments.

\subsection{Closures}
\label{sub:closures}

Closures are special lambdas that carry a snapshot of the scope at
the time of their creation.
\\

\subsubsection{Declaring closures}
\label{ssub:declaring_closures}

There are two methods of defining closures in Angle:

\paragraph{Using Return}
\label{par:using_return}

When using the @return@ statement with a function or lambda,
a closure is returned instead, using the current scope.
\\
If the value being returned is already a closure (already has an
associated scope), then the current scope will be super-imposed onto
the global scope of the closure - i.e, the current scope becomes the
parent scope of the old global scope of the closure, and the current
global scope becomes the new global scope of the closure.

\paragraph{Using the Dollar Operator}
\label{par:using_the_dollar_operator}

Using the dollar operator before a bare lambda will declare the lambda
to be a closure, and capture scope appropriately.
\\
Thus:
\begin{spec}
defun foo() {
  return (() x;);
}

bar = foo();
\end{spec}
Is the same as
\begin{spec}
bar = \$(() x;);
\end{spec}

\subsubsection{Closure Example}
\label{ssub:closure_example}

\begin{spec}
  x = 7;
  defun foo() {
    defun bar(y) {
      return (+ x y);
    }
    return \$bar;
  }

  fun = foo();

  fun(1);
  # > 8

  x = 5;

  fun(1);
  # > 8

  fun2 = foo();

  fun2(1);
  # > 6
\end{spec}

% TODO: Check this!
In the above example, @foo@ returns a closure @bar@ which takes a
single argument and returns the sum of its argument and the value of
@x@ as it was when the closure was produced.
\\
When @fun@ is defined, the global value of @x@ is 7, thus in the
scope of the closure, global @x@ will always equal 7.
\\
When @x@ is redefined later on, this does not affect the value of @x@
that is used by the closure assigned to @fun@. But when @fun2@ is
defined, as the scope that @bar@ captures is different, so will its
value of @x@.



\subsection{Accessing lambdas}
\label{sub:accessing_lambdas}

As every variable in Angle can have both a function \textit{and}
value definition, \textit{and} functions are first-class citizens,
this means that occasionally the lambda associated with a variable
may need to be retrieved.
\\
Angle provides the dollar operator (@\$@) that when used on an
identifier, will return an expression representing the lambda stored
in the variable.


\subsubsection{Producing values from functions}
\label{ssub:producing_values_from_functions}

% FIXME: Fix the phrasing.
By default, when no return value is specified in a function, the last
produced value will be returned. Otherwise, the @return@ statement can
be used to exit early from the function and set the produced value to
that specified.


\begin{spec}
defun foo() {
  1;
}

foo = (() 1;);
# Equivalent to above.

foo = 2;

foo;
# 2

foo();
# 1

\$foo;
# (() 1;)
\end{spec}


@foo@ is defined as both a function (that just returns the integer 1)
and a value (the integer 2).

When using @foo@ as an expression, without calling it, it just
returns the value definition. Likewise, when called as a function it
returns the expected value 1. However, when the dollar operator is
used, the function's definition is returned.

\subsubsection{Grammar}
\label{ssub:grammar}

\paragraph{Function calls}
\label{par:function_calls}

\begin{spec}

arglist       = `(' { expr `,' } `)'         ;

function_call = [ `@' ] simple_ident arglist ;
\end{spec}

The optional @@\@@ sign in front of the identifier indicates whether
to call the function as a constraint or a regular function.
\footnote{See Section~\ref{ssub:parameter_constraints}}

\paragraph{Function definition}
\label{par:function_definition}


\begin{spec}
function_def = simple_ident `(' { parameter `,' } `)' stmt ;

parameter    = [ `!' | `\$' | `..' ]
               simple_ident
               [ `:@' simple_ident [ arglist ] ]           ;
\end{spec}

\section{Variables}
\label{sec:variables}

Variables reference a location in memory that represents the data
associated with them. In Angle, variables can have two sets of data:
the first is a non-function value, such as an integer, string etc..;
and the second is a lambda that represents the variable as a function
 (see Section~\ref{sub:accessing_lambdas} on how to access this
 value).

\subsection{Resolving variables}
\label{sub:resolving_variables}

% TODO: Add scope stuff.
Angle is lexically scoped - meaning that the location at which a
variable is defined determines where it can be accessed.
\\
Angle's standard method of resolving variables is to first check
the current scope, then recursively check the outer scopes until
the global scope has been checked or a definition for the variable
has been found.
\\
When no value is found an exception is raised.

\subsubsection{Different methods of resolving variables}
\label{ssub:different_methods_of_resolving_variables}

On top of the standard resolution method, Angle provides two built-in
functions for resolving variables differently:

\begin{itemize}
  \item @nonlocal@ - will do the same as standard resolution, but
  starting from the parent scope instead.
  \item @global@ - will only check the global scope.
\end{itemize}


% TODO: Check the phrasing of this section.
\subsection{Assignment}
\label{sub:assignment}

Angle supports three assignment operators: @=@, @|=@, and @||=@; which
represent local assignment, nonlocal assignment and global assignment
respectively.

\subsubsection{Local assignment}
\label{ssub:local_assignment}

When assigning to the local scope, if a definition for the variable
exists then it is overwritten, otherwise the variable is newly
defined.

\subsubsection{Nonlocal assignment}
\label{ssub:nonlocal_assignment}

When assigning to a nonlocal scope, first the given identifier is
resolved in the local-most scope that is a parent of the current
scope, then this variable is overwritten with the given value. If no
nonlocal variable exists for the identifier, then the operation fails
with an exception.

\subsubsection{Global assignment}
\label{ssub:global_assignment}

When assigning to the global scope, the same process as for local
assignment is performed, but in the global scope instead of the
current scope.

\subsubsection{Grammar}
\label{ssub:grammar}

\begin{spec}
stmt_assign     = local_assign
                | nonlocal_assign
                | global_assign           ;

local_assign    = simple_ident `=' expr   ;
nonlocal_assign = simple_ident `|=' expr  ;
global_assign   = simple_ident `||=' expr ;
\end{spec}


\section{Exceptions and exception handling}
\label{sec:exceptions_and_exception_handling}

A number of unexpected things can go awry during runtime, things such
as types being used incorrectly, functions being called with the
wrong number of arguments, requesting files that don't exist, and
attempting to access closed handles, to name a few.
\\
Angle attempts to anticipate many of these issues, and when they occur
it wraps them up, along with their critical information, and throws
them as exceptions.
\\
Once thrown, an exception will propagate up the stack (function calls)
until it either reaches the top level, where it will be displayed
as an error to the user, or it is caught in a @try...catch@ statement.

\subsection{Handling exceptions}
\label{sub:handling_exceptions}

The @try...catch@ statement allows the programmer to handle exceptions
that are raised during execution.

\subsubsection{Try}
\label{ssub:try}

The @try@ keyword initializes a @try...catch@ statement. Any code
wrapped in the @try@ section is executed sequentially until it either
finishes normally, or an exception is raised.
\\
If the code finishes normally, then the rest of the @try...catch@
statement is skipped and the next statement is executed.
\\
If the code results in an exception, then the rest of the body will
be skipped and the @catch@ component will be passed the exception
for handling.

\subsubsection{Catch}
\label{ssub:catch}

The catch component of a @try...catch@ consists of one or more
@catch@ keywords, each followed by the exceptions they handle, and
the code that should be executed when they are handling an exception.

\paragraph{Exceptions}
\label{par:exceptions}

Each @catch@ clause takes either a single keyword, or a list of
keywords that name the types of exceptions they can handle.
\\
When an exception is passed to the @catch@ block, each @catch@ clause
is tried, from top to bottom, until either a @catch@ matches the
current exception, or there are no more @catch@ clauses.
\\
In the case that the exception is matched by one of the clauses, the
accompanying body of code is executed, then the @try...catch@
statement is exited.
\\
If none of the @catch@ clauses matched the exception, then it is
re-raised and will continue its propagation.

\paragraph{Break}
\label{par:break}

A special form of the @break@ statement can be used in the body of a
@catch@ clause.\footnote{See Section~\ref{ssub:break} for other uses
of @break@.}
\\
@break :try@ will exit the current @catch@ clause, and repeat the
@try...catch@ statement from the beginning of the @try@. This removes
the need for wrapping a @try...catch@ in a @while@ loop for repeated
user input, as demonstrated below.

\subsubsection{Example of handling exceptions}
\label{ssub:example_of_handling_exceptions}

A common example of @try..catch@ usage is with handling user input;
this is usually a case that shouldn't crash the program, so it makes
sense to handle it.

\begin{spec}
  try {
    user_input = input("Enter an integer: ");
    res = asType(1, user_input);
  }
  catch :read {
    print("That wasn't an integer!");
    break :try;
  }
\end{spec}

In this scenario, an attempt is being made to convert the user's
input (string) to an integer; when the user's input does not
represent a valid integer string, a @:read@ exception is thrown. This
is then caught by the @catch@ and the user is notified of their
mistake before being asked to enter another integer.

\subsubsection{Grammar}
\label{ssub:grammar}

\begin{spec}
  stmt_try_catch = `try '   stmt catch_spec { catch_spec } ;

  catch_spec     = `catch ' catch_keyword stmt             ;

  catch_keyword  = litKeyword | `[' { litKeyword `,' } `]' ;
\end{spec}

\subsection{Raising exceptions}
\label{sub:raising_exceptions}

Angle allows the user to throw new exceptions or re-raise exceptions
being handled.
\\
The @raise@ statement takes a single keyword and either raises a new
exception (that can be caught by using the same keyword) or re-raises
an exception, based on the circumstances.

\subsubsection{Re-raising exceptions}
\label{ssub:re_raising_exceptions}

% FIXME: I have a case of the *cough* bad *cough* *cough* wording...
When the @raise@ statement is used within the body of a @catch@
clause, and the exception being handled matches the exception being
raised, then the old exception will be re-raised with all the
original information.

\paragraph{Example}
\label{par:example}

% FIXME: I too *cough* *splutter* have a case of the *gasp* bad
% phrasing.
An example of when a programmer may wish to re-raise exceptions is
when some operations are to be performed on a resource which must
be closed when it is finished with.
\\
In the example below, the @catch@ clause ensures that the handle
gets closed should any exceptions arise in the @try@ block.

\begin{spec}
  try {
    my_handle = open("some_file.txt", "<");
    ...some code...
    close(my_handle);
  } catch :error {
    close(my_handle);
    raise :error;
  }
\end{spec}

\subsubsection{Raising new exceptions}
\label{ssub:raising_new_exceptions}

When using @raise@ in a scenario that doesn't fulfill the criteria
required in Section~\ref{ssub:re_raising_exceptions}, a new exception
is created. User exceptions are limited to a single keyword name,
but are otherwise treated the same as regular exceptions.

\begin{spec}
  try {
    for i in (1..10) do {
      if (> i 5) then {
        raise :greaterThan5;
      }
    }
  }
  catch :greaterThan5 {
    print("Got a number larger than 5!");
  }
\end{spec}

In this case the user exception is @:greaterThan5@, and is handled
directly.

\subsubsection{Grammar}
\label{ssub:grammar}

\begin{spec}
stmt_raise = `raise ' litKeyword ;
\end{spec}


\subsection{Built-in exceptions}
\label{sub:built_in_exceptions}

The following is a comprehensive list of the exceptions that are
built into Angle.

\subsubsection{Special exceptions}
\label{ssub:special_exceptions}

The @:error@ keyword can be used to catch all exceptions.
\\
The @:user@ keyword can be used to catch user exceptions.

\subsubsection{Type exceptions}
\label{ssub:type_exceptions}

Raised when issues arise with parameter constraints or types are used
incorrectly. Can be caught with @:typeError@.
\\

\begin{tabular}{l p{7cm}}
 Keyword & When thrown \\
 @:typeMismatch@ & If two types should be the same but aren't. \\
 @:typeUnexpected@ & If a type was used in a place where another was
 expected. \\
 @:typeNotValid@ & The type used is not valid in the current
 situation. \\
 @:typeCast@ & There is no possible conversion from one type to
 another when attempting a type conversion. \\
 @:typeMismatchOp@ & Wrong types are used in an operation. \\
 @:typeExpectConstr@ & A constraint returns false for a given value
 (in the function head). \\
 @:typeConstrWrongReturn@ & A constraint returned a non boolean
 value. \\
 @:typeAnnWrong@ & A value doesn't satisfy a parameter annotation. \\
\end{tabular}


\subsubsection{Name exceptions}
\label{ssub:name_exceptions}

Raised when issues arise with the naming of things. Can be caught with
@:nameError@.
\\

\begin{tabular}{l p{7cm}}
 Keyword & When thrown \\
 @:nameNotDefined@ & An identifier cannot be resolved. \\
 @:nameNotDefinedFun@ & There is no lambda definition for a
 variable. \\
 @:nameNotDefinedLit@ & There is no value definition for a
 variable. \\
 @:nameNotOp@ & Not a valid operator. \\
 @:assignToBuiltin@ & An attempt was made to assign to a
 non-overwritable built-in. \\
\end{tabular}

\subsubsection{Call exceptions}
\label{ssub:call_exceptions}

Raised when issues arise when calling functions. Can be caught with
@:callError@.
\\

\begin{tabular}{l p{7cm}}
 Keyword & When thrown \\
 @:wrongNumberOfArguments@ & Function called with the wrong number of
 arguments. \\
 @:builtin@ & An issue occurred when calling a built-in function. \\
 @:malformedSignature@ & Bad operation call. \\
\end{tabular}

\subsubsection{Keyword exceptions}
\label{ssub:keyword_exceptions}

Raised when keywords are used incorrectly. Can be caught with
@:keywordError@.
\\

\begin{tabular}{l p{7cm}}
 Keyword & When thrown \\
 @:returnFromGlobal@ & @return@ was used in the global scope.
\end{tabular}

\subsubsection{Value exceptions}
\label{ssub:value_exceptions}

Raised when Angle's types are used incorrectly. Can be caught with
@:valueError@.
\\

\begin{tabular}{l p{7cm}}
 Keyword & When thrown \\
 @:indexOutOfBounds@ & Attempting to access a non-existent index
 of a list. \\
 @:badRange@ & The types used in a range don't match up. \\
 @:infiniteRange@ & Attempting to fully evaluate a range that would
 produce an infinite (or extremely large) set of values. \\
 @:nonEnum@ & An enumerable type was expected but not received. \\
 @:divideByZero@ & Zero was used as the denominator in an
 expression. \\
\end{tabular}


\subsubsection{IO exceptions}
\label{ssub:io_exceptions}

Raised when issues arise whilst performing IO. Can be caught with
@:ioError@.
\\

\begin{tabular}{l p{7cm}}
 Keyword & When thrown \\
 @:alreadyExists@ & One of the arguments in an IO operation already
 exists. \\
 @:doesNotExist@ & One of the arguments in an IO operation does
 not exist. \\
 @:alreadyInUse@ & One of the arguments in an IO operation is a
 single-use resource and is already being used. \\
 @:deviceFull@ & The device is full. \\
 @:eof@ & End of file has been reached. \\
 @:illegalOperation@ & Operation was not possible. \\
 @:permission@ & User does not have sufficient privileges to perform
 the operation. \\
\end{tabular}
\\

These closely follow the errors outlined in the Haskell's IO error
system. \cite{Base System.IO.Error}

\subsubsection{Syntax exceptions}
\label{ssub:syntax_exceptions}

Raised when issues arise with reading code at runtime. Can be caught
with @:syntaxError@.
\\

\begin{tabular}{l p{7cm}}
 Keyword & When thrown \\
 @:syntax@ & Invalid syntax. \\
 @:read@ & String does not represent a literal. \\
\end{tabular}

\subsubsection{Include exceptions}
\label{ssub:include_exceptions}

Raised when issues arise when including other files. Can be caught
with @:include@.
\\

\begin{tabular}{l p{7cm}}
 Keyword & When thrown \\
 @:doesNotExist@ & Attempting to include a non-existent file. \\
 @:syntax@ & File contains invalid syntax. \\
\end{tabular}


\section{Looping Structures}
\label{sec:looping_structures}

Repeated execution of a block of code can generally be achieved by
two methods: recursion and iteration, both of which are supported in
Angle.

\subsection{Recursion}
\label{sub:recursion}

% FIXME: Feels like there ought to be a pause near 'which when'.
Recursion is achieved by a function self-calling with reduced
arguments. A base case exists which when satisfied will return a
well-formed value.
\\
\\
\textit{For the @factorial@ function, the base case is when the argument
equals 0, and the value being passed in is reduced by 1 each time.}
\begin{spec}
  defun factorial(n) {
    if (== n 0) then return 1;
    return (* n factorial((- n 1)));
  }
\end{spec}

Other recursive forms exist (such as tail-recursion), but Angle
provides a while loop (see Section~\ref{sub:iteration}) rendering
such forms unnecessary.


\subsection{Iteration}
\label{sub:iteration}

Angle supports two constructs for iteration: @for@ loops and @while@
loops.

\subsubsection{For loops}
\label{ssub:for_loops}

For loops, when given a enumerable value such as a list or range,
will pass over the contained values, assigning each element to a
temporary variable for access in the body.
\\
\textit{Welcoming several users with the use of a for loop.}
\begin{spec}
users = ["Jannet", "Harry", "Theo"];

for user in users do {
  print("Welcome ", user);
}
\end{spec}

\paragraph{For loop result}
\label{par:for_loop_result}

A special feature of for loops is that they will collect the final
value of each iteration into a list that is then returned as the
result at the end of the loop (providing there are no breaks).
Thus @for i in (1..5) do i;@ results in the list @[1, 2, 3, 4, 5]@.

\subsubsection{While loops}
\label{ssub:while_loops}

Unlike their @for@ loop counterparts, which traverse a series of
values, @while@ loops execute until some condition is met.
\footnote{Note that this example would be better solved with a
for loop with a range (@for _ in (1..9)@).}

\begin{spec}
  count = 1;
  while (< count 10) do {
    print("Count is less than 10!");
    count = (+ count 1);
  }
\end{spec}

\subsection{Controlling loops}
\label{sub:controlling_loops}

There are times at which it may be useful to exit a loop before it
would naturally finish, or skip the rest of the current execution.
\\
% TODO: Better wording...
The @break@ and @continue@ statements provide support for these cases
respectively.


\subsubsection{Break}
\label{ssub:break}

The @break [val]@ statement ends the execution of the current looping
structure, and sets the value produced to @val@, when supplied.
% TODO: Maybe add link to the section where break :try is used (or
% mention special cases of :break)

\begin{spec}
nom = 0;
denom = 10;
while true do {
  try {
    print((/ nom denom));
  } catch :divideByZero {
    print("Oops!");
    break; # Stop the loop!
  }
  nom = (+ nom 1);
  denom = (- denom 1);
}
\end{spec}


\subsubsection{Continue}
\label{ssub:continue}

@continue@ skips the rest of the current loop iteration, causing the
looping structure to start its next cycle.

\begin{spec}
for i in (1..5) do {
  if (== i 3) then continue; # Won't print for 3
  print(i);
}
\end{spec}

\subsection{Grammar}
\label{sub:grammar}

\subsubsection{Looping structures}
\label{ssub:looping_structures}

\begin{spec}
stmt_loop  = loop_for | loop_while             ;

loop_for   = `for'   ident `in' expr `do' stmt ;
loop_while = `while'            expr `do' stmt ;
\end{spec}

\subsubsection{Loop control flow}
\label{ssub:loop_control_flow}

\begin{spec}

loop_control     = control_break
                 | control_continue    ;

control_break    = `break'    [ expr ] ;
control_continue = `continue'          ;
\end{spec}



\section{Input and Output}
\label{sec:input_and_output}

% FIXME: Want better wording for this.
Although the logic of a program can be defined in terms of pure
functions that do not interact with the outside world - a non-library
program must perform some input-output operations in order to be
useful.
\\
Angle provides several functions for IO operations.


\subsection{Interactive with the terminal}
\label{sub:interactive_with_the_terminal}

A common need in scripts written for use in the terminal is to be able
to perform basic interaction with the user. Angle facilitates this
with the built-in @print@ and @input@ functions.
\\
\begin{description}
  \item[@print(string)@] prints the given string to @stdout@.
  \item[@input(string)@] prints @string@ to @stdout@ before returning
  the response from @stdin@.
\end{description}

A great deal of basic user interaction can be achieved just through
the use of these two functions.

\subsection{Handles}
\label{sub:handles}

Angle makes use of handles to perform IO operations. A handle is a
reference to a resource on the system, such as a file descriptor which
provides access to some IO resource for reading and/or writing.

\subsubsection{Standard streams}
\label{ssub:standard_streams}

On Unix systems there exist three standard file descriptors to access
the three standard streams: @stdin@ is the input stream; @stdout@ is
the output stream; and @stderr@ which is used for error messages.
\\
Angle provides handles to these three descriptors by default, in the
form of the variables @stdin@, @stdout@ and @stderr@.

\subsubsection{Obtaining handles}
\label{ssub:obtaining_handles}

The built-in @open@ function, which takes the form
@open(file_name, access_mode)@, returns a handle providing
access to the file @file_name@ in the specified @access_mode@.

\paragraph{Access modes}
\label{par:access_modes}

There are two main access modes in general: read and write.
Write is further split into append and write (clobber).
`Write (clobber)' is used when the contents of the file shouldn't be
preserved and will overwrite the contents of the file when writing.
`Append' on the other hand will preserve the contents and add the
new text to the end of the file.
\\
\\
The four access modes are summarized below:
\\
\\
\begin{tabular}{c c c c}
Symbol & Read & Write & Append \\
@"<"@  & Yes  & No    & - \\
@">"@  & No   & Yes   & No \\
@">>"@ & No   & Yes   & Yes \\
@"<>"@ & Yes  & Yes   & No \\
\end{tabular}
\\
\\
For example, if you wanted to read from a file called "file.txt", you
could use @open("file.txt", "<")@ to obtain the necessary handle.
% Angle provides four possible access modes for handles: read
% (represented by @"<"@), write (@">"@), append (@">>"@), and
% read-write (@"<>"@).

\subsubsection{Reading handles}
\label{ssub:reading_handles}

Angle's built-in @read@ function provides various means of reading
from a handle's character stream. @read(handle)@ reads the entirety
of the remaining text, @read(handle, int)@ will read @int@ lines,
then the modifier @:char@ can be appended to the call to read
individual characters.
\\
\\
% TODO: Check this (and the above paragraph)
\begin{tabular}{l p{7cm}}
 Form & Meaning \\
 @read(handle)@ & Reads from @handle@ until it hits the end of the
 stream. \\
 @read(handle, int)@ & Reads @int@ lines from @handle@. \\
 @read(:char, handle)@ & Reads a single character from @handle@. \\
 @read(:char, handle, int)@ & Reads @int@ characters from @handle@. \\
\end{tabular}

\subsubsection{Writing to handles}
\label{ssub:writing_to_handles}

% TODO: Check the wording.
% As mentioned previously, there are two main write-modes that can be
% used with handles in Angle; these produced the stated effects when
% used with the @write@ function, which takes a handle and some text
% and writes the text to the handle.

As mentioned previously, there are two main write-modes that can be
used with handles: write (clobber) and write (append).
\\
The clobber mode will overwrite the current contents of the resource
on each write, whereas the append mode will add the string to the
end of the resource.
\\
In both cases, when writing to a non-existent file, the file will be
created.

\subsubsection{Closing handles}
\label{ssub:closing_handles}

When a handle is no longer in use it can be closed for reading and
writing with the @close@ function. It is advisable to explicitly close
handles when they are no longer needed to free up file descriptors and
allow them to be accessed by other operations later on.


% \subsubsection{Basic functions for user interaction}
% \label{ssub:basic_functions_for_user_interaction}
%
% A basic commandline program could easily get away with using just two
% of Angle's IO functions for user interaction: @print@ and @input@.
% \\
% \paragraph{Print}
% \label{par:print}
%
% The @print@ function takes some text and prints it to the @stdout@
% handle

\section{Including code from other files}
\label{sec:including_code_from_other_files}

It is essential for code-reusability and the creation of libraries to
be able to load code from other files in a program. The ability to
do this means that sets of functions can be defined in one file, then
used by many other programs such that the functions do not need to be
written again.
\\
There are two main methods of achieving this in Angle:

\subsection{Eval}
\label{sub:eval}

% TODO: Want better phrasing.
The @eval@ built-in function takes a string and attempts to parse it
as Angle source - this can be useful for loading small sections of
source from a trusted location on the fly.
\\
There are a few issues with this - any use of @eval@ with user input
is risky, as there is the potential for malicious code to be injected,
instead the @asType@ built-in should be used for converting strings
to other types.

\subsection{Include}
\label{sub:include}

The best method of loading entire files is the built-in @include@
function. @include@ takes a filename (or handle) and attempts to
execute the contained text. Syntax errors are handled by @include@.
\\
@include@, when passed a filename, will first check the standard Angle
library locations for the specified file, then the relative path. If
the given filename happens to be a relative or absolute path
(starts with @.@, @/@ etc..) then the library locations will not be
checked.


\section{Operations}
\label{sec:operations}


Operations (consisting of operators and operands) are the fundamental
means of manipulating data in Angle.
\\
Angle supports three types of operator: infix binary, prefix unary
and prefix variadic. The infix binary operators (such as @=@) take
two operands, one on either side. The prefix unary operators take a
single operand and are placed before this operand. The prefix variadic
operators are used as the first symbol within parentheses, and take
a non-set number of operands, separated by whitespace, until the
closing parenthesis.

\subsection{Operator types}
\label{sub:operator_types}

Operators in Angle mainly come under four categories: arithmetical,
logical, relational and assignment.

\subsubsection{Arithmetical Operators}
\label{ssub:arithmetical_operators}

Arithmetical operators, which are generally variadic, perform
mathematical arithmetic operations such as addition, multiplication
and division.

\begin{table}[h!]
  \begin{tabular}{l c c c}
  Operation      & Symbol & Example       & Result \\
  Addition       & @+@    & @(+ 1 2 3)@   & @6@ \\
  Subtraction    & @-@    & @(- 1 2 3)@   & @-4@ \\
  Multiplication & @*@    & @(* 1 2 3)@   & @6@ \\
  Division       & @/@    & @(/ 1.0 2 3)@ & @0.1666666...@ \\
  Exponentiation & @**@   & @(** 2 4)@    & @16@ \\
  Negation       & @-@    & @-x@          & @-5@ (if @x = 5@)\\
  \end{tabular}
  \caption{Arithmetical Operators}\label{tab:arithmetical_operators}
\end{table}


\subsubsection{Logical Operators}
\label{ssub:logical_operators}

Logical operators perform logical operations on booleans and are also
mostly variadic.

\begin{table}[h!]
  \begin{tabular}{l c c c}
  Operation & Symbol & Example    & Result \\
  OR        & @|@    & @(| false false true)@ & @true@ \\
  AND       & @&@    & @(& true true false)@  & @false@ \\
  NOT       & @^@    & @^(& true true false)@  & @true@ \\
  \end{tabular}
  \caption{Logical Operators}\label{tab:logical_operators}
\end{table}

\subsubsection{Relational Operators}
\label{ssub:relational_operators}

Relational operators perform comparison between different types, all
the relational operators are variadic.

There is a pair-wise grouping with relational operators, thus
@(< 1 2 3)@ becomes @1 < 2 AND 2 < 3@, or @1 < 2 < 3@.

\begin{table}[h!]
  \begin{tabular}{l c c c}
  Operation             & Symbol & Example    & Result \\
  Equality              & @==@   & @(== 1 2)@ & @false@ \\
  Less than             & @<@    & @(< 1 2)@  & @true@ \\
  Greater than          & @>@    & @(> 1 2)@  & @false@ \\
  Greater than or equal & @>=@   & @(>= 1 2)@ & @false@ \\
  Less than or equal    & @<=@   & @(<= 1 2)@ & @true@ \\
  \end{tabular}
  \caption{Relational Operators}\label{tab:relational_operators}
\end{table}

\subsubsection{Assignment Operators}
\label{ssub:assignment_operators}

Assignment operators are all infix binary, and the use-case is always
the same; associate some data with an identifier. See
Section~\ref{sub:assignment} for a more detailed explanation on how
assignment works.

\begin{table}[h!]
  \centering{In a new non-global scope.} \\
  \begin{tabular}{l c c c}
  Operation           & Symbol & Example   & Result \\
  Local assignment    & @=@    & @x = 1@   & Local @x = 1@ \\
  Nonlocal assignment & @|=@   & @x |= 1@  & Error \\
  Global assignment   & @||=@  & @x ||= 1@ & Global @x = 1@ \\
  \end{tabular}
  \caption{Assignment Operators}\label{tab:assignment_operators}
\end{table}

\subsubsection{A word on operations}
\label{ssub:a_word_on_operations}

There are a few important features to note about Angle's operators:
\\
\paragraph{Assignment is not an expression}
\label{par:assignment_is_not_an_expression}

All operations represent expressions, with the exception of the
assignment operators. This means that the assignment operators cannot
be embedded within other operations.
% \\
% The second is that, although general use cases for the standard
% operations are intuitive, many of the operators will act differently
% depending on their arguments.

\paragraph{Overloading}
\label{par:overloading}

Many of the variadic operators are designed to act differently
depending on their arguments: for example, the addition operator (@+@)
performs arithmetic addition when all the arguments are numeric, but
will perform appending when the first element is a list.
\\
Many of the special cases and miscellaneous operators are covered in
greater detail in the documentation for
\haskmodule{Angle.Exec.Operations}.

\paragraph{List expansion in variadic operations}
\label{par:list_expansion_in_variadic_operations}

Many of the variadic operators support the special case of being
passed a single list. When this happens, the list is expanded and
the operator acts upon the contents of the list,
thus @(+ [a,b,c,...,x,y,z])@ becomes @(+ a b c ... x y z)@.



\subsection{Grammar}
\label{sub:grammar}

\begin{spec}

operation =     unop    expr
          | `(' varop { expr } `)'         ;

unop      = `^' | `-'                      ;

varop     = `+' | `-'  | `/' | `**' | `*'
                | `|'  | `&' | `>=' | '++'
                | `<=' | `>' | `<'  | `==' ;
\end{spec}


\section{Conditionals}
\label{sec:conditionals}

A common feature to almost all programming languages is a structure
for conditionally evaluating code based on the result of an
expression. The canonical example of this is the `if' conditional,
that executes the accompanying body if the given expression evaluates
to `true', an `else' form is also usually present.
\\
Angle is no exception to this trend and implements its own conditional
statements: `if', and its counterpart `unless'.

\subsection{Truth in Angle}
\label{sub:truth_in_angle}

Many languages have different notions of what constitutes a `truthy'
value. In Perl, all values except for @0@, @"0"@, @""@, @()@, and
@undef@ are considered `true'; in Ruby, only @nil@ and @false@ are
considered to be `false'; in Haskell, only the values @True@ and
@False@ have any meaning when used as booleans.
\\
% TODO: Check this...
Angle follows the latter path, with @true@ and @false@ being the only
values that can be used in a boolean context. The main reason for this
is that it makes code easier to understand - writing
@if nonzero(num_users) then...@ is a lot easier to understand than
@if num_users then...@ (in my opinion).



\subsection{Grammar}
\label{sub:grammar}

\begin{spec}
stmt_condition = cond_if | cond_unless                     ;

cond_if        = `if'     expr `then' stmt [ `else' stmt ] ;
cond_unless    = `unless' expr        stmt [ `else' stmt ] ;
\end{spec}

% FIXME: Not really happy about this whole section.

\part{Implementation}
\label{prt:implementation}

This section provides an overview of the implementation of Angle, some
important design choices and their ramifications and the overall
layout of the project.

\section{Project structure}
\label{sec:project_structure}

The Angle implementation is split into four sections:

\subsection{Language representation}
\label{sub:language_representation}

This is the internal representation of Angle's language structures;
it describes how the various types relate to each other and the
general structure the abstract syntax tree (AST) will take.
\\
The actual implementation is not described further, but the
documentation for \haskmodule{Angle.Types.Lang} covers this in great
detail. Additionally, Part~\ref{prt:language_reference} provides
a higher-level overview.

\subsection{Executable}
\label{sub:executable}

% TODO: Check this section.
The executable is the tool that users will make use of in order to
run software written in Angle.
\\
The software provided, called `angle' is command-line based and
self-contained. Options provided by the executable can be found
by running @angle --help@.

\subsection{Parser}
\label{sub:parser}

% TODO: Check the wording.
The parser has the job of compiling the textual source code into
an AST representation of Angle within Haskell.
\\
Within the module structure, the collection of modules
\haskmodule{Angle.Parse.*} and \haskmodule{Angle.Scanner} define the
implementation of the parser.
\\
% TODO: This wording isn't very good.
Within these modules, the @Parser a@ monad is used to define the
computational ability of the parser itself.

\subsection{Interpreter}
\label{sub:interpreter}

The role of the interpreter is to execute the program according to
the structure of the AST produced by the parser.
\\
% TODO: Huh... Do you need this?
Within the implementation, the interpreter is the first stage that
is able to interact via IO, all previous steps are pure-monadic.
\\
% TODO: Don't think this feels quite right...
The advantage of having the parser execute purely in terms of pure
functions means that any two source-texts that are the same produce
the exact same abstract syntax tree - as they should.


\section{Process}
\label{sec:process}

% TODO: Still not happy with this...
The four main components of Angle mentioned in
Section~\ref{sec:project_structure} interact to form the following
execution method:

% TODO: Maybe make a better distinction between the `programmer'
% and the `user'
\begin{enumerate}
  \item \textit{User:} The programmer writes a program using Angle syntax.
  \item \textit{Executable:} The source file is run using the `angle' program.
    \begin{enumerate}
      \item \textit{Parser:} An attempt is made to compile the source
      to the abstract syntax tree based on the
      \textit{language representation}.
        \begin{enumerate}
          \item If the syntax does not coincide with that expected,
          the program will halt and alert the user.
        \end{enumerate}
      \item \textit{Interpreter:} The AST is executed.
        \begin{enumerate}
          \item Run-time errors are raised as exceptions that may
          be caught by the user. If an exception makes it to the
          top-level, the program will halt and alert the user.
        \end{enumerate}
    \end{enumerate}
  \item \textit{Executable:} The program exits and memory is freed.
\end{enumerate}



% \begin{description}
%   \item[executable] for running programs, the main interface for the
%     user. See Section~\ref{sub:the_software} for more information.
%   \item[parser] which will deal with translating source code into
%     an abstract syntax tree that represents the language.
%   \item[interpreter] which executes the AST produced by the parser
%     and performs IO actions.
%   % TODO: Check this.
%   \item[language representation] describes Angle in terms of Haskell,
%   and provides the form that the abstract syntax tree will take.
% \end{description}

\section{Parser implementation}
\label{sec:parser_implementation}

\subsection{Relevant Modules}
\label{sub:relevant_modules}

\haskmodule{Angle.Scanner} defines the parser type.
\haskmodule{Angle.Parse.Parser}, \haskmodule{Angle.Parse.Helpers} and
\haskmodule{Angle.Parse.Token} implement the parser functions.
\haskmodule{Angle.Types.Lang} defines language structures in terms of
Haskell types.

\subsection{Overview}
\label{sub:parser_overview}

Angle builds its parser on top of the @Parser a@ monad - a custom
monad that supports a combinatory parsing style.
% Angle builds its parser on a custom parser-combinator style parsing
% monad.
\\
\\
\textit{The parser-library components:}
\begin{itemize}
  \item \haskmodule{Angle.Scanner} defines the @Parser a@ monad and the
fundamental functionality of the parser.
  \item \haskmodule{Angle.Parse.Helpers} defines the functions to support
  combinatory parsing.
\end{itemize}
%\haskmodule{Angle.Scanner} defines the @Parser a@ monad and the
%fundamental functionality of the parser; \haskmodule{Angle.Parse.Helpers}
%defines the functions to support combinatory parsing.

\textit{Parser implementation:}
\begin{itemize}
  \item \haskmodule{Angle.Parse.Token} uses the previously defined
  combinators to build parsers for the basic structures in Angle
  (strings, keywords, numerics).
  \item \haskmodule{Angle.Parse.Parser} uses combinators defined in
\haskmodule{Angle.Parse.Helpers}, along with the parsers defined in
\haskmodule{Angle.Parse.Token} to define the parsers for each of the
language constructs, and the main parser that combines these in order
to parse an entire Angle program.
\end{itemize}


\subsection{The Parser Monad}
\label{sub:the_parser_monad}

\subsubsection{What is a monad?}
\label{ssub:what_is_a_monad_}

In the context of a purely functional language such as Haskell, a
monad is a structure that represents a certain type of computation
and the rules associated with it. Monads are particularly useful
because they allow the combination of effects whilst following the
accompanying rules. \cite{Eric Walkingshaw Monads}

\paragraph{The Maybe monad}
\label{par:the_maybe_monad}

An example of a monad in Haskell is the @Maybe a@ monad. @Maybe a@
is often used to represent some computation that may fail.
\\
\\
\textit{A @Maybe a@ data declaration}
\begin{spec}
data Maybe a = Nothing | Just a
\end{spec}

There are two operations associated with monads: `return' and `bind'.
`return' allows a non-monadic value to be lifted into the monad, and
`bind' allows the combination of monadic computations.
\\
For the @maybe a@ monad, `return' wraps the value in the @Just@
constructor, and `bind' unwraps the value from the `Just' constructor
and passes it to the next function, or produces `Nothing' if the
first computation produces `Nothing' as well.

\begin{spec}
return a == Just a

Nothing >>= _ == Nothing

Just a >>= f == f a
\end{spec}


\subsubsection{The Parser Monad}
\label{ssub:the_parser_monad}

With the definition of a monad out of the way, it can be understood
that the @Parser a@ monad should have the operations `bind' and
`return'.
\\
The example of the @Maybe a@ monad given above is very simplistic,
it does one thing and one thing only. The @Parser a@ monad will have
to provide a lot more functionality if it is to be used for language
parsing.

\paragraph{Monad Transformers}
\label{par:monad_transformers}

Monad transformers are special structures that allow the combination
of monads. \cite{RWH Monad Transformers, Wikibooks Monad Transformers}
\\
Monad transformers must satisfy the standard monad laws, but possess
an additional operation `lift' that promotes monadic computations
to the combined monad of the transformer. \cite{transformers}
\\
This effectively allows the stacking of monadic effects, for example,
if a monad was required that could both keep state and fail, the
@maybe a@ monad could be combined with the @state s a@ monad via
the @MaybeT m a@ monad transformer.
\begin{spec}
type FailAndState s a = MaybeT (State s) a
\end{spec}

\paragraph{What it should do}
\label{par:what_it_should_do}

With monads and monad transformers in mind, all that needs to be done
is to state the desired computational abilities, pick the correct
monads and combine them to form the final monad.

\paragraph{State}
\label{par:state}

% TODO: Better wording please.
The @Parser a@ monad will obviously need to be able to keep track of
its internal state. The parser will be running through a source file,
making requests to the scanner and collecting characters to form the
result.
\\
The @State s a@ monad was chosen to satisfy this as it provides a
simple interface and all the required functionality without
side-effects. \cite{mtl State}

\paragraph{Environment}
\label{par:environment}

The @Parser a@ monad will need access to a source string throughout
its lifetime. In Haskell, the @Reader e a@ monad is used when a static
`environment' of type @e@ should be passed along with computations
without being altered. \cite{mtl Reader}

\paragraph{Failure}
\label{par:failure}

Although it would be nice to think that all input to the parser would
be well-formed, it is likely that a string could not be parsed due
to being syntactically incorrect. The @Parser a@ monadic should be
able to fail, and describe \textit{why} it failed.
\\
The @Maybe a@ monad mentioned earlier can be used to represent
computations that can fail, but it is limited in that it can only
indicate that the computation failed, not \textit{why}.
\\
For failure with additional information, the @Except e@ monad can
be used.\footnote{Initially `ErrorT' was used, but due to
depreciation `ExceptT' was used instead - \cite{mtl Except}}


\paragraph{The monad stack}
\label{par:the_monad_stack}

To combine these monads the use of monad transformers is required,
as mentioned earlier.
\\
An important point to note is that combining monads is, in general,
not commutative - meaning that the order of operations \textit{is}
important.
\\
% TODO: Oh God... Please fix the phrasiiiinggg...
An example of this would be @ExceptT e (State s) a@ versus
@StateT s (Except e) a@. The former describes a monad in which it is possible for the result
of each computation to be a failure, whereas the latter describes
a monad in which the entire computation can fail.
\\
\begin{spec}
type ES a = ExceptT String (State Int) a
type SE a = StateT Int (Except String) a

message1 = return "hello" :: ES String
message2 = return "hello" :: SE String

runState (runExceptT message1) 1
> (Right "hello", 1)
# The result (first part of the tuple) is wrapped in the
# Either e a monad.

runExcept (runStateT message2 1)
> Right ("hello", 1)
# The entire computation is wrapped in the Either e a monad.
\end{spec}

% FIXME: Uhmm... Repetition?
As the above example shows, the former monad is wrapping the inner
value in exceptions, whereas the latter is wrapping the whole
computation with potential failure.

\paragraph{Ordering}
\label{par:ordering}

With this in mind, the ordering of the stack can be decided.
\\
Clearly an @ExceptT e m a@ transformer will have to sit on the top
of the stack, as either the whole file can be parsed, or none
of the file.
\\
Regarding the @Reader e a@ and @State s a@ monads, the ordering
isn't particularly important; they both produce the same results
(a reader that produces a stateful computation of type @State s a@ is
the same as a stateful computation that produces a reader of type
@Reader e (s, a)@ when fully evaluated - as the environment has no
effect on the final result).
\\
Out of personal preference I put the @Reader e a@ monad on the bottom
of the stack.\footnote{@SyntaxError@, @Position@ and @Source@ are not
the actual names of the types used. See \textit{Angle.Scanner} for the
actual definition.}
\\
\\
\textit{The Parser a monad}
\begin{spec}
type Parser a = ExceptT SyntaxError (StateT Position (Reader Source)) a
\end{spec}

\subsection{Scanner}
\label{sub:scanner}

\subsubsection{Relevant modules}
\label{ssub:relevant_modules}

\haskmodule{Angle.Scanner} defines the scanner.

\subsubsection{What is a Scanner?}
\label{ssub:what_is_a_scanner_}

% TODO: Check the wording!
The scanner reads in individual characters from source and passes
them to other components (namely the parser and/or lexer) to be
converted to tokens.% \footnote{http://forums.devshed.com/programming-languages-139/interpreter-compiler-312483.html\#post1342279}
The scanner has to keep track of its position in source in order to
be able to backtrack and/or provide contextual syntax errors.

\subsubsection{The basics}
\label{ssub:the_basics}

There are two main requirements for the scanner:
\begin{itemize}
  \item It is able to read characters from source.
  \item It is able to indicate the position at which these characters
  were read.
\end{itemize}

\subsubsection{The implementation}
\label{ssub:the_implementation}

I decided to implement the scanner as two parts: a type representing
the information that the scanner would require to run, which would
be embedded into the @Parser a@ monad; and the base-most function
for the parser-combinator functionality.

\paragraph{As a function}
\label{par:as_a_function}

As a function, the scanner is represented by @scanChar@, defined in
\textit{Angle.Scanner}. @scanChar@ has the simple type @Parser Char@,
it is a parser that either produces a character as the result, or
fails. Another description of @scanChar@ might be:
\textit{`the parser for a grammar in which any character is valid,
with the only invalid token being the empty string'}. This is very
useful as it provides the most simple grammar on top of which all the
other parsing functions can be built, by refining the grammar from
`any character' to a set of characters in sequence.
\\
% TODO: This feels a bit incomplete, like it is leading somewhere?
The @scanChar@ function does have a couple of other duties, such as
explicitly updating the state (See below), and checking for special
characters such as newlines.
% FIXME: What below?

\paragraph{As a type}
\label{par:as_a_type}

The @ScanState@ datatype defined in \textit{Angle.Scanner} represents
the information required for the scanner to look ahead, backtrack
and present positional information.
\\
a @ScanState@ consists of three attributes: @sourcePos@, which is
the current position in source;\footnote{See the @SourcePos@ type in
\textit{Angle.Scanner}.} @sourceRemaining@, which is the source text
that has not yet been traversed; and @sourceScanned@, which represents
the previously traversed source text.
\\
This information is then used as the state for the @Parser a@ monad,
and is updated by the scanner function @scanChar@ during parsing.


\subsection{Parsing Angle}
\label{sub:parsing_angle}

The @Parser a@ monad forms the basis of parsing in Angle, but with
just the definition of the monad and the scanner, the only supported
grammar is the most general one.
\\

\subsubsection{Layers}
\label{ssub:layers}

As mentioned in Section~\ref{sub:parser_overview}, the parser is split over
several modules.

\begin{itemize}
  \item \haskmodule{Angle.Scanner} defines the @Parser a@ monad and
  the scanner functionality.
  \item \haskmodule{Angle.Parse.Helpers} builds upon the functionality
  provided by \haskmodule{Angle.Scanner} to create the set of
  parser-combinator functions.
  \item \haskmodule{Angle.Parse.Token} defines primitive parsers for
  Angle's basic structures.
  \item \haskmodule{Angle.Parse.Parser} defines the Angle parser.
\end{itemize}
Having a `Parser' type alone doesn't automatically allow the parsing
of Angle syntax. Angle must be described in Haskell's type system
and functions must be defined to parse each of the constructs.

% The parsing functions are defined through three modules.
% \haskmodule{Angle.Parse.Helpers} defines the most basic parsers for use in
% other modules. \haskmodule{Angle.Parse.Token} defines parsers that deal
% with very basic structures, such as strings and integers.
% \haskmodule{Angle.Parse.Parser} defines the parsers that read Angle syntax
% into Angle types.

\subsubsection{Implementing strings - an example}
\label{ssub:implementing_strings_an_example}

As an example of the process of defining a new Angle feature, I will
use string literals.

Functions from \haskmodule{Angle.Parse.Helpers}:
\begin{description}
  \item[@char     :: Char     -> Parser Char@] parses the specified character.
  \item[@manyTill :: Parser b -> Parser a -> Parser [a]@] a
    higher-order parser that parses until the first parser is
    satisfied.
  \item[@anyChar  :: Parser Char@] essentially the same as the base
    scanner function - parses any character.
\end{description}

Using these functions means that a parser could be defined in
\haskmodule{Angle.Parse.Token} for parsing a basic string.\footnote{There are a
lot of edge cases when parsing strings, see
\haskmodule{Angle.Parse.Token.tokString} for a better representation.}

\begin{spec}
string :: Parser String
string = char `"' *> manyTill (char `"') anyChar
\end{spec}

Which would parse some text surrounded by double quotes.

Then, assuming the type

\begin{spec}
data LangLit = ...
             | LitStr String
             | ...
\end{spec}

defined in \haskmodule{Angle.Types.Lang}, a parser can be implemented in
\haskmodule{Angle.Parse.Parser} for wrapping a Haskell string in an Angle string.

\begin{spec}
litStr :: Parser LangLit
litStr = liftM LitStr tokString
\end{spec}

Then this process is repeated for any other structures that need to
be parsed.

\section{Design choices}
\label{sec:design_choices}

This section outlines certain design choices, why they were made
and their impact upon the language.

\subsection{Lists as both expressions and literals}
\label{sub:lists_as_both_expressions_and_literals}

\subsubsection{The problem}
\label{ssub:the_problem}

\paragraph{Angle has few types}
\label{par:angle_has_few_types}

Angle provides relatively few data-types compared to many other
languages, thus each one has to take on the roles that would
potentially be carried out by several data-types in other
languages.

\paragraph{Storing data}
\label{par:storing_data}

Often times a programmer may wish to dump large amounts of data
in a file, then read this back at a later date. Angle's lists are
the obvious candidate for this scenario.

\paragraph{Lists must be expressions}
\label{par:lists_must_be_expressions}

Angle's lists must be expressions on some level, otherwise it would
not be possible to have lists containing values that are unknown
before runtime (e.g. in @[1, x, 4]@, the value of @x@ is unknown
until it is evaluated).
\\
Angle's method of dealing with this is to wrap every element of a list
in an expression during the AST generation. The main issue here is
that every time a list needs to be evaluated, each of the elements
needs to be evaluated first.

\subsubsection{The solution}
\label{ssub:the_solution}

The solution is fairly simple - have lists as both expressions and
literals.

\paragraph{Literals}
\label{par:literals}

Lists have a literal read syntax - when parsing a program, every time
a list is encountered an attempt is made to read it as a literal -
this can only succeed if all the contained values are literals as
well.
\\
If a list can be read as a literal, then the whole list can be
directly evaluated without needing to first evaluate each of the
elements, thus reducing computational complexity especially when
dealing with very large lists.
\\
If the list cannot be read as a literal then each of the elements
is wrapped in an expression, as before.


\subsection{Variadic operators}
\label{sub:variadic_operators}

Angle's prefix variadic operators are quite unconventional. They are
based upon a Lisp style, but are very different from operators in
most languages.

\subsubsection{The problem}
\label{ssub:the_problem}

Initially I intended to implement binary infix operators, the same
as many other languages. I soon encountered the issue of precedence
with my parsing library and all the workarounds for this were ugly
and verbose.

\subsubsection{The solution}
\label{ssub:the_solution}

The solution was to have the programmer explicitly state the order
in which operations would be executed.
\\
% TODO: Better phrasing please.
For example: with binary operators, @1 + 2 * 5 / 7@ becomes
@1 + (2 * 5 / 7)@, which then becomes @(1 + (2 * (5 / 7)))@ because
even though multiplication and division generally have the same
precedence, they are often defined to have left or right associativity
that determine how equal precedence is resolved (left in this case).
However, in Angle, an equal statement would be @(+ 1 (* 2 (/ 5 7)))@,
thus there cannot be precedence clashes due to each layer needing to
be evaluated before the higher layers.

% TODO: I think this should be moved to the language reference.
\subsubsection{Variadic operators are versatile}
\label{ssub:variadic_operators_are_versatile}

Although not my initial choice for operators, the variadic operators
have proved to be very powerful.\footnote{Section~\ref{ssub:a_word_on_operations}
outlines some prominent features.}

\paragraph{Flat operations}
\label{par:flat_operations}

Conventional binary operators only have two operands, thus when an
operations needs to be applied to a set of values, one might have to
do this: @a + b + c + ... + x + y + z@, this is inconvenient, and due
to most of Angle's operators being variadic, all these operations
could be combined into one: @(+ a b c ... x y z)@.


\part{Conclusion}
\label{prt:conclusion}

Angle satisfies its initial design requirement as a general-purpose
programming language. It supports most major language features,
including subroutines, variables, looping and conditional structures,
exception handling and file IO.
\\
For small projects, the standard structures, along with the support
for input and output to files, as well as direct calls to shell
commands, means that most use-cases should be handled directly.
\\
For larger projects, the ability to embed code from other files
through built-in functions should encourage the use of multiple source
files in a single project, and the creation of libraries to reduce
code duplication.
\\
Regarding the internal structure: the design of Angle allows for new
syntax, built-in functions, types and language structures to be defined
relatively easily. This extensibility means that creating new language
features in the future is a definite possibility.
% FIXME: ^ not sure about 'definite possibility'
\\
The documentation for the source code is satisfactory, and the use of
Haddock means that this documentation may be displayed in a
user-friendly manner.
\\
The use of Cabal has greatly sped up development of Angle, as changes
to directory structure need only be updated in the cabal file, and
cabal's support for benchmarks and testing aided in the development
work-flow.

\section{Implementation}
\label{sec:implementation_changes}

As is often the case, with hindsight I am aware of areas of the
implementation that may have been improved if certain knowledge was
available at the beginning of the project.
\\
For example, Haskell supports Generalized Algebraic Datatypes - a
system that allows you to explicitly state types signatures of the
constructors of a type. \cite{GHC GADTs}
Knowledge of this when starting the project may have made it easier
and cleaner to come up with a representation for the language
structures.
\\
\\
In the early stages of the project there were some issues with the
testing frameworks - the sizes of the test-cases that QuickCheck was
generating were too large to be completed in a reasonable time. With
\hasklib{test-framework}, the initial testing framework, I had great
difficulty controlling the size of individual test-cases. After
switching to \hasklib{tasty} these issues were more easily dealt with.
\\
For future projects I shall have to do more research into testing
libraries to ensure they can cope with all my projects' needs before
commencing on the actual project itself.

\subsection{Errors and debugging}
\label{sub:errors_and_debugging}

An important part of any language is its ability to convey error
messages to the programmer, and provide support for debugging the
software.
\\
This was a design consideration from quite early in the project, and
I feel that Angle's error reporting system is satisfactory for the
project level. Angle provides no separate debugging utilities, bar the
interactive mode accessible through the software. In future projects
I would encourage a more ingrained error system, with much more
detailed messages - especially at the parsing stage.

\subsection{Type system}
\label{sub:type_system}

My choice was to have a dynamic type system for Angle - this was done
intentionally to reduce reliance on Haskell's type system to improve
my understanding of coping with non-static type systems.
\\
In the future, when this is not a goal in mind, I believe it would be
wise to allow Haskell to enforce type-correctness in any small
language implementations. This would not only reduce the required
effort, but also perhaps provide some speed increases and allow me to
better understand how to use existing type-systems to my advantage.


\section{Final comments}
\label{sec:final_comments}

After having now created a basic programming language, I feel I have
gained enough knowledge to study the topic more in-depth and implement
more small languages. I will perhaps revisit Angle in the future to
implement additional features and review how my methods have changed.


\begin{thebibliography}{99}
 \bibitem{Haskell}
 The Haskell programming language. \url{https://www.haskell.org/}
 \bibitem{Cabal}
  The Haskell Cabal. \url{https://www.haskell.org/cabal/}
 \bibitem{Haddock}
  Haddock: A Haskell Documentation Tool.
  \url{https://www.haskell.org/haddock/}
 \bibitem{GHC}
  The Glasgow Haskell Compiler. \url{https://www.haskell.org/ghc/}
 \bibitem{Git}
  Git. \url{https://git-scm.com/}
 \bibitem{Haskell Platform}
  Haskell Platform.
  \url{https://www.haskell.org/platform/contents.html}
 \bibitem{QuickCheck}
  QuickCheck, Version 2.7.6.
    \url{https://hackage.haskell.org/package/QuickCheck}
 \bibitem{Tasty}
  Tasty, Version 0.10.1.2.
    \url{https://hackage.haskell.org/package/tasty}
 \bibitem{Criterion}
  Criterion. \url{https://hackage.haskell.org/package/criterion}
 \bibitem{Compiled Versus Interpreted Languages}
  Vanguard Software. Compiled vs. Interpreted Languages.
  \url{http://www.vanguardsw.com/dphelp4/dph00296.htm}
 \bibitem{Ray Toal Paradigms}
  Ray Toal, Loyola Marymount University. Programming Paradigms.
  \url{http://cs.lmu.edu/~ray/notes/paradigms/}
 \bibitem{MSDN Functional vs. Imperative}
  Microsoft Developer Network. Functional Programming vs. Imperative
  Programming.
  \url{https://msdn.microsoft.com/en-gb/library/bb669144.aspx}
 \bibitem{HaskellWiki Functional programming}
  HaskellWiki. Functional programming.
  \url{https://wiki.haskell.org/Functional\_programming}
 \bibitem{Keunwoo Lee CSE 341}
  Keunwoo Lee. UW-CSE 341 (Programming Languages) Winter 2004 Course
  Notes. Dynamic typing vs. static typing.
  \url{http://courses.cs.washington.edu/courses/cse341/04wi/lectures/13-dynamic-vs-static-types.html}
 \bibitem{C2 Dynamic Typing}
  C2 Wiki. Dynamic Typing. \url{http://c2.com/cgi/wiki?DynamicTyping}
 \bibitem{C2 Weakly Typed}
  C2 Wiki. Weakly Typed. \url{http://c2.com/cgi/wiki?WeaklyTyped}
 \bibitem{LMG BNF}
  Lars Marius Garshol. BNF and EBNF: What are they and how do they
  work?
  \url{http://www.garshol.priv.no/download/text/bnf.html\#id1.2.}
 \bibitem{Matt Might BNF}
  Matt Might. The language of languages.
  \url{http://matt.might.net/articles/grammars-bnf-ebnf/}
 \bibitem{Dave Marshall Literal Values}
  Dave Marshall. Literal Values.
  \url{https://www.cs.cf.ac.uk/Dave/Multimedia/node71.html}
 \bibitem{Eric Walkingshaw Monads}
  Eric Walkingshaw. Monads.
  \url{http://web.engr.oregonstate.edu/~walkiner/teaching/cs583-fa14/slides/6.Monads.pdf}
 \bibitem{RWH Monad Transformers}
  Bryan O'Sullivan, Don Stewart, and John Goerzen. Real World Haskell.
  Chapter 18. Monad Transformers.
  \url{http://book.realworldhaskell.org/read/monad-transformers.html}
 \bibitem{Wikibooks Monad Transformers}
  Wikibooks. Haskell/Monad transformers.
  \url{https://en.wikibooks.org/wiki/Haskell/Monad\_transformers}
 \bibitem{Base Data.Char}
  base: Basic libraries. Version 4.8.1.0. Data.Char.
  \url{https://hackage.haskell.org/package/base-4.8.1.0/docs/Data-Char.html\#t:Char}
 \bibitem{Base Prelude Double}
  base: Basic libraries. Version 4.8.1.0. Prelude.
  \url{http://hackage.haskell.org/package/base-4.8.1.0/docs/Prelude.html\#t:Double}
 \bibitem{Base System.IO.Error}
  base: Basic libraries. Version 4.8.1.0. System.IO.Error.
  \url{http://hackage.haskell.org/package/base-4.8.1.0/docs/System-IO-Error.html}
 \bibitem{transformers}
  Andy Gill, Ross Paterson. transformers: Concrete functor and monad
  transformers. \url{https://hackage.haskell.org/package/transformers}
 \bibitem{mtl State}
  Andy Gill. mtl: Monad classes, using functional dependencies.
  Version 1.1.0.2. Control.Monad.State.Lazy.
  \url{https://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-State-Lazy.html}
 \bibitem{mtl Reader}
  Andy Gill. mtl: Monad classes, using functional dependencies.
  Version 1.1.0.2. Control.Monad.Reader.
  \url{https://hackage.haskell.org/package/mtl-1.1.0.2/docs/Control-Monad-Reader.html}
 \bibitem{mtl Except}
  Andy Gill.
  \emph{mtl: Monad classes, using functional dependencies.}
  Version 2.2.1. Control.Monad.Except.
  \url{https://hackage.haskell.org/package/mtl-2.2.1/docs/Control-Monad-Except.html\#t:ExceptT}
 \bibitem{GHC GADTs}
  The GHC Team. The Glorious Glasgow Haskell Compilation System
  User's Guide, Version 6.6.1. Chapter 7. GHC Language Features.
  Section 7.5. Generalized Algebraic Data Types (GADTs).
  \url{https://downloads.haskell.org/~ghc/6.6.1/docs/html/users\_guide/gadt.html}
\end{thebibliography}

\end{document}
